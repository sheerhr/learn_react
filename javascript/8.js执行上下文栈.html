<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        function makeFunc() {
            var name = "Mozilla";
            function displayName() {
                alert(name);
            }
            return displayName;
        }
        var myFunc = makeFunc();
        myFunc();

        /*
            第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。

            第二步，执行第19行代码时，调用makeFunc()，产生makeFunc()执行上下文环境，压栈，并设置为活动状态。

            第三步，执行完第17行，makeFunc()调用完成。按理说应该销毁掉makeFunc()的执行上下文环境，但是这里不能这么做。
            注意，重点来了：因为执行makeFunc()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。
            而正巧合的是，返回的这个函数体中，还有一个自由变量name要引用makeFunc作用域下的makeFunc()上下文环境中的name。
            因此，这个name不能被销毁，销毁了之后myFunc函数中的name就找不到值了。因此，这里的fn()上下文环境不能被销毁，
            还依然存在与执行上下文栈中。
        */

    </script>
</body>

</html>