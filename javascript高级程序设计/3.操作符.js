/************************************
 * 只操作一个值的操作符叫做一元操作符*
 ************************************/
(function test1() {
    let age = 29;
    let anotherAge = --age + 2;
    console.log(age);
    console.log(anotherAge);
})();

/**
 * 位操作符
 * 按位非操作符用波浪符（ ~ ）表示,它的作用是返回数值的一补数
 * 实际上，尽管两者返回的结果一样，但位操作的速度快得多。这是因为位操作是在数值的底层表示上完成的。
 */
(function test2() {
    let num1 = 25;
    let num2 = ~num1;
    console.log(num2);
    // let num1 = 25;
    // let num2 = -num1 - 1;
    // console.log(num2);
})();

/**
 * 按位与
 * 25 和 3 的按位与操作的结果是 1。为什么呢？看下面的二进制计算过程：
 * 25 = 0000 0000 0000 0000 0000 0000 0001 1001
 *  3 = 0000 0000 0000 0000 0000 0000 0000 0011
 * ---------------------------------------------
 * AND = 0000 0000 0000 0000 0000 0000 0000 0001
 */
(function test3() {
    let result = 25 & 3;
    console.log(result); // 1
})();

/**
 * 按位或
 * 25 = 0000 0000 0000 0000 0000 0000 0001 1001
 *  3 = 0000 0000 0000 0000 0000 0000 0000 0011
 * ---------------------------------------------
 * OR = 0000 0000 0000 0000 0000 0000 0001 1011
 */
(function test4() {
    let result = 25 | 3;
    console.log(result); // 1
})();

/**
 * 按位异或
 * 按位异或与按位或的区别是，它只在一位上是 1 的时候返回 1（两位都是 1 或 0，则返回 0）。
 * 25 = 0000 0000 0000 0000 0000 0000 0001 1001
 *  3 = 0000 0000 0000 0000 0000 0000 0000 0011
 * ---------------------------------------------
 * XOR = 0000 0000 0000 0000 0000 0000 0001 1010
 */
(function test5() {
    let result = 25 ^ 3;
    console.log(result); // 26
})();

/**
 * 左移
 * 比如，如果数值 2（二进制 10）向左移 5 位，
 * 就会得到 64（二进制 1000000），
 * 注意在移位后，数值右端会空出 5 位。左移会以 0 填充这些空位，让结果是完整的 32 位数值
 * 注意，左移会保留它所操作数值的符号。比如，如果2 左移 5 位，将得到64，而不是正 64。
 */
(function test6() {
    let oldValue = 2; // 等于二进制 10
    let newValue = oldValue << 5; // 等于二进制 1000000，即十进制 64
    console.log(newValue);
})();

/**
 * 有符号右移
 * 有符号右移由两个大于号（ >> ）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。
 * 有符号右移实际上是左移的逆运算
 * 比如，如果将 64 右移 5 位，那就是 2：
 * 同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后。
 * ECMAScript 会用符号位的值来填充这些空位，以得到完整的数值。
 */
(function test7() {
    let oldValue = 64; // 等于二进制 1000000
    let newValue = oldValue >> 5; // 等于二进制 10，即十进制 2
    console.log(newValue);
})();

/**
 * 无符号右移
 * 无符号右移用 3 个大于号表示 >>> 
 * 对于正数，无符号右移与有符号右移结果相同。仍然以前面有符号右移的例子为例，64 向右移动 5 位，会变成 2
 * 无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理
 * 在对-64 无符号右移 5 位后，结果是 134 217 726。这是因为-64 的二进制表示是 11111111111111111111111111000000，
 * 无符号右移却将它当成正值，也就是 4 294 967 232。把这个值右移 5 位后，结果是
 * 00000111111111111111111111111110，即 134 217 726。
 */
(function test8() {
    let oldValue = -64; //  等于二进制 11111111111111111111111111000000
    let newValue = oldValue >>> 5; // 等于十进制 134217726
    console.log(newValue);
})();